## 实验 1：MPS 键维 vs Hankel 秩（验证定理 4.1 & 4.4）

### 目标 & 假设

**目标：**

1. 数值验证
   $$
   \mathrm{rank}(H_a)\le D,\quad \mathrm{rank}(H_p)\le D^2
   $$
   并紧密靠近理论上界（定理 4.1）。

2. 验证“典型满秩”现象（定理 4.4）：在随机 MPS 情况下，Hankel 秩几乎总是达到上界（在数值阈值意义下）。

**假设（要验证）：**

- 对于**随机 MPS**（参数分布对 Lebesgue 测度绝对连续）：

  - 当前缀/后缀集合满足 $|P|,|S|\ge D^2$ 时，
    $$
    \mathrm{rank}(H_p(P,S)) \approx \min(D^2,\ |P|,\ |S|)
    $$

  - 绝大多数样本达到 $D^2$（数值上接近满秩）。

- 对于**结构化 MPS**（例如 7.2A 的对角构造）：

  - Hankel 秩显著低于 $D^2$，例如 rank=1 或 3。

------

### 实验设置（参数选择）

1. **字母表大小**

   - 取 $\Sigma = {0,1}$ （$|\Sigma|=2$）为主；可选扩展到 $|\Sigma|=4$ 看 scaling。

2. **序列长度 $L$**

   - $L \in {8,10,12}$。

   - 为了让 Theorem 4.4 真正“可见”，需要确保前缀/后缀数目不限制秩：

     - 用切分点 $t_*=\lfloor L/2\rfloor$，
     - 前缀数 $|P| = |\Sigma|^{t_*}$，后缀数 $|S| = |\Sigma|^{L-t_*}$，
     - 希望 $|P|,|S| \ge D^2$。

   - 因此，对于给定 $(|\Sigma|,D)$，只保留那些满足
     $$
     |\Sigma|^{\lfloor L/2\rfloor} \ge D^2,\quad
     |\Sigma|^{L-\lfloor L/2\rfloor}\ge D^2
     $$
     的 $(L,D)$ 组合。否则理论上也只能看到 rank$\le\min(D^2,|P|,|S|)$。

3. **键维 $D$**

   - $D\in{2,3,4}$。
   - 对每个 $(|\Sigma|,L,D)$ 组合，生成足够多随机样本（例如 50–100 个 MPS）。

4. **MPS 类型**

   - **随机 MPS：**
     - 目标是“高纠缠、无显式结构”，满足绝对连续分布的假设。
   - **结构化 MPS：**
     - 用于构造 rank-deficient 的反例，如：
       - 7.2A 的对角 MPS（理论秩=1）；
       - 7.2B 式的 rank-3 构造。

------

### 关键实现细节

#### 1. 随机 MPS 的生成（建议方案）

以 $\Sigma={0,1}$ 为例，本地物理维度 $d=2$：

对每个位置 $t=1,\dots,L$：

1. 对每个符号 $\sigma\in\Sigma$ 生成一个随机复矩阵
   $$
   A_t(\sigma)\in\mathbb C^{D\times D}
   $$

   - 元素可取 i.i.d. 复高斯（real/imag ~ $\mathcal N(0,1)$）。

2. 对该位置做一次**左规范化**（可选但推荐）：

   - 计算：
     $$
     M_t = \sum_{\sigma\in\Sigma} A_t(\sigma) A_t(\sigma)^\dagger
     $$

   - 令 $M_t^{-1/2}$ 为 $M_t$ 的 Hermitian 逆平方根（通过特征分解或 SVD）。

   - 更新：
     $$
     A_t(\sigma) \leftarrow M_t^{-1/2} A_t(\sigma)
     $$

   - 这样就满足 $\sum_\sigma A_t(\sigma)A_t(\sigma)^\dagger = I$（近似），有助于数值稳定。

**边界向量**

- 取 $\alpha,\beta\in\mathbb C^D$ 为随机复向量，然后归一化为 $|\alpha|_2=|\beta|_2=1$。

**归一化整态**

- 直接利用 MPS 表达计算所有 $x\in\Sigma^L$ 的振幅 $\psi(x)$，设置归一化因子：
  $$
  Z = \sum_{x} |\psi(x)|^2,\quad \psi(x)\leftarrow \psi(x)/\sqrt Z.
  $$

> 说明：
>  也可以从随机量子电路（Haar 随机单比特+有限深度纠缠）构造 MPS，但对“键维 vs Hankel 秩”的验证来说，直接在 MPS 空间采样更简单直接。

#### 2. 结构化 MPS 的生成

- **rank-1 例子（7.2A）**：
  - 设置 $D=2$,
  - $A(0) = \mathrm{diag}(1,\eta)$, $A(1)=\mathrm{diag}(\eta,1)$，$0<\eta<1$，
  - $\alpha = \beta = e_1$（第一标准基）。
  - 该构造理论上保证 $\mathrm{rank}(H_p)=1$。
- **rank-3 例子（7.2B）**：
  - 基于 7.2B 中的描述构造边界 $\alpha=\beta=[1,c]^\top$ 等参数。
  - 该构造理论上 $\mathrm{rank}(H_p)\le 3$，且通过调整 $(c,\eta)$ 可观察近奇异行为。

#### 3. Hankel 矩阵的构造

**(a) 生成全部字符串与振幅/概率**

- 枚举 $x\in\Sigma^L$（例如通过二进制计数）。

- 对每个 $x=(x_1,\dots,x_L)$：
  $$
  \psi(x) = \alpha^\top\Big(\prod_{t=1}^L A_t(x_t)\Big)\beta,\qquad
  p(x) = |\psi(x)|^2
  $$

- 可以顺便检查 $\sum_x p(x)\approx 1$，做归一化校验。

**(b) 选择前缀/后缀集合 $P,S$**

- 采用**固定切分点** $t_*=\lfloor L/2\rfloor$：
  - 前缀集合 $P = \Sigma^{t_*}$；
  - 后缀集合 $S = \Sigma^{L-t_*}$。
- 对于任意 $u\in P, v\in S$，它们拼成长度 $L$ 的字符串 $x=uv$。

**(c) 振幅 Hankel 矩阵 $H_a$**

- 定义：
  $$
  H_a(u,v) = \psi(uv).
  $$

**(d) 概率 Hankel 矩阵 $H_p$**

- 定义：
  $$
  H_p(u,v) = p(uv) = |\psi(uv)|^2.
  $$

> 注意：
>  这里的 Hankel 是**长度固定、按 $(u,v)$ 索引的矩阵**，而不是“每个长度-$L$ 串只出现一次”的向量结构。
>  这意味着理论上 rank$\le \min(D^2,|P|,|S|)$，在实验统计中要记得做这个剪裁（见指标部分）。

------

### 数值 rank 的计算与指标

#### 数值 rank 定义

实际计算中要选一个相对阈值 $\tau$（例如 $10^{-10}$）：

- 对矩阵 $M$ 做 SVD：$M=U\Sigma V^\dagger$，

- 令 $\sigma_{\max}=\Sigma_{11}$，

- 定义
  $$
  \mathrm{rank}_\tau(M) = \#\{i:\sigma_i \ge \tau\,\sigma_{\max}\}.
  $$

通常取 $\tau\in[10^{-8},10^{-12}]$。可以在附录里说明这个选取。

#### 主要指标

对每个 $(|\Sigma|,L,D)$ 和 MPS 类型（随机/结构化），统计：

1. **秩分布**

   - 振幅 Hankel：$\mathrm{rank}_\tau(H_a)$ 的直方图；
   - 概率 Hankel：$\mathrm{rank}_\tau(H_p)$ 的直方图。

2. **归一化秩比例**

   - 振幅：$\mathrm{rank}_\tau(H_a)/\min(D,|P|,|S|)$；
   - 概率：$\mathrm{rank}_\tau(H_p)/\min(D^2,|P|,|S|)$。

3. **“典型满秩”频率**

   - 对随机 MPS，看
     $$
     \Pr\big[\mathrm{rank}_\tau(H_p)=\min(D^2,|P|,|S|)\big]
     $$
     随样本数的统计频率（例如 100 次试验中有多少次达到最大秩）。

4. **结构化对照**

   - 对 7.2A 构造，验证 $\mathrm{rank}_\tau(H_p)=1$（在数值容差内）。
   - 对 7.2B 构造，验证 $\mathrm{rank}_\tau(H_p)\le 3$，并可进一步观察第三奇异值随 $L$ 的衰减趋势（与你理论中的 $(\sqrt2\eta)^L$ 讨论呼应）。

可选附加指标（如果你有精力）：

- 记录 $\kappa(H_p)=\sigma_{\max}(H_p)/\sigma_{\min}(H_p)$ 的分布，和 7.2B 中的劣条件分析对应起来。

------

### 预期结果（如何“验证”理论）

1. **定理 4.1：秩上界**

   对所有实验设置和所有样本，应当观测到：
   $$
   \mathrm{rank}_\tau(H_a) \le \min(D,|P|,|S|),\qquad
   \mathrm{rank}_\tau(H_p) \le \min(D^2,|P|,|S|),
   $$
   且在数值上几乎不会超出这个范围（如果超出，九成是阈值/数值误差问题，要检查代码）。

2. **定理 4.4：典型满秩**

   在随机 MPS 的条件下：

   - 在满足 $|P|,|S|\ge D^2$ 的组合上，期望看到
     $$
     \Pr\big[\mathrm{rank}_\tau(H_p)=D^2\big] \approx 1
     $$
     即大多数随机样本的 Hankel 都“数值满秩”；

   - 直方图中，$\mathrm{rank}_\tau(H_p)$ 高度集中在 $D^2$ 附近。

3. **结构化反例**

   - 对 7.2A 构造，$\mathrm{rank}_\tau(H_p)$ 始终为 1，不随 $D$ 和 $L$ 增长，这说明“低纠缠/强结构”确实可以把 Hankel 秩压得很低；
   - 对 7.2B 构造，可以数值验证 $\mathrm{rank}_\tau(H_p)\le 3$，并通过第三奇异值随 $L$ 增大而迅速变小，看见“近奇异但不完全奇异”的情形。

这些现象将直接支撑你在正文中关于：

- “$D^2$ 上界是紧的”
- “随机参数化 MPS 典型地给出满秩 Hankel”
- “低纠缠/结构化模型才真正对应低秩 Hankel 假设”

这些关键论点。

------

### 建议的实验流程（Step-by-step）

可以写成伪代码（Python 实现会很直观）：

1. 固定一组全局参数：
   - 字母表 $\Sigma$, 长度集合 $\mathcal L$, 键维集合 $\mathcal D$, 样本数 $N_{\text{MPS}}$。
2. 对每个 $(|\Sigma|,L,D)$：
   1. 检查 $|\Sigma|^{\lfloor L/2\rfloor}, |\Sigma|^{L-\lfloor L/2\rfloor} \ge D^2$，否则跳过。
   2. 循环 $N_{\text{MPS}}$ 次：
      1. 生成随机 MPS（按上面规范化过程）。
      2. 枚举 $x\in\Sigma^L$，计算 $\psi(x)$ & $p(x)$，并归一化。
      3. 构造 $H_a, H_p$（用固定切分点 $t_*$）。
      4. 对它们做 SVD，计算数值秩。
   3. 统计 rank 分布和归一化比例，并画直方图/箱型图或散点图。
3. 对结构化 MPS 重复上述过程，但不需要多样本，只要几组参数就足够展示 rank-deficient 行为。

------

### （可选）简单代码骨架示意（Python / NumPy）

不一定要真的跑，只是方便你 later implement：

```
import numpy as np
from itertools import product

def random_mps(L, D, Sigma):
    # 生成随机 A_t(σ)、alpha、beta，并做左规范化
    A = []
    for t in range(L):
        A_t = {}
        mats = []
        for sigma in Sigma:
            M = np.random.randn(D, D) + 1j * np.random.randn(D, D)
            A_t[sigma] = M
            mats.append(M @ M.conj().T)
        Mt = sum(mats)
        # 逆平方根
        evals, evecs = np.linalg.eigh(Mt)
        inv_sqrt = evecs @ np.diag(1.0 / np.sqrt(evals + 1e-12)) @ evecs.conj().T
        for sigma in Sigma:
            A_t[sigma] = inv_sqrt @ A_t[sigma]
        A.append(A_t)
    alpha = np.random.randn(D) + 1j * np.random.randn(D)
    beta  = np.random.randn(D) + 1j * np.random.randn(D)
    alpha /= np.linalg.norm(alpha)
    beta  /= np.linalg.norm(beta)
    return A, alpha, beta

def psi_from_mps(A, alpha, beta, x):
    D = alpha.shape[0]
    M = np.eye(D, dtype=complex)
    for t, sigma in enumerate(x):
        M = M @ A[t][sigma]
    return alpha.conj().T @ M @ beta

def build_hankel(A, alpha, beta, Sigma, L):
    t_star = L // 2
    P = list(product(Sigma, repeat=t_star))
    S = list(product(Sigma, repeat=L - t_star))
    Hp = np.zeros((len(P), len(S)))
    Ha = np.zeros_like(Hp, dtype=complex)
    # 预先缓存所有 ψ(x)
    amp_cache = {}
    for u_idx, u in enumerate(P):
        for v_idx, v in enumerate(S):
            x = u + v
            if x not in amp_cache:
                amp_cache[x] = psi_from_mps(A, alpha, beta, x)
            psi = amp_cache[x]
            Ha[u_idx, v_idx] = psi
            Hp[u_idx, v_idx] = abs(psi) ** 2
    # 归一化（可选，严格上 Hp 的每个元素就是 p(x)，总和=1）
    return Ha, Hp

def numerical_rank(M, tau=1e-10):
    s = np.linalg.svd(M, compute_uv=False)
    return np.sum(s >= tau * s[0])
```

> 实际跑的时候要注意：
>
> - 复杂度 $O(|\Sigma|^L)$ 很快会爆；但你当前选的 $L\le 12$，$|\Sigma|=2$，总共 $4096$ 个字符串，构造 Hankel 也还在可承受范围内。
> - 复杂度更高的组合（比如 $|\Sigma|=4,L=12$）就要谨慎一点，但仍然是可以的。